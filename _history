{"entries":[{"timestamp":1745759943156,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"7@eQwkcCqF=*a!]!ITVo\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":62},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," id=\".T6dU(E3|hfB@Cka|~|`\" x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":49,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"enum HttpMethod {\n    GET,\n    POST,\n    PUT,\n    HEAD,\n    DELETE,\n    PATCH,\n    OPTIONS,\n    CONNECT,\n    TRACE\n}\n\n/**\n * IoT commands.\n */\n//% color=#34c3a2 icon=\"\\uf1eb\" block=\"IoT\"\nnamespace iot {\n\n    let isWifiConnected = false\n    /**\n     * Make a serial connection between micro:bit and ESP8266.\n     */\n    //% block=\"connect to ESP8266|TX %txPin|RX %rxPin|Baud rate %baudrate|SSID = %ssid|Password = %passwd\"\n    //% txPin.defl=SerialPin.P15\n    //% rxPin.defl=SerialPin.P1\n    //% baudRate.defl=BaudRate.BaudRate115200\n    export function initialize_ESP8266(txPin: SerialPin, rxPin: SerialPin, baudRate: BaudRate, ssid: string, passwd: string): void {\n        let result = 0\n\n        isWifiConnected = false\n\n        serial.redirect(\n            txPin,\n            rxPin,\n            baudRate\n        )\n        sendAtCmd(\"AT\")\n        result = waitAtResponse(\"OK\", \"ERROR\", \"None\", 1000)\n\n        sendAtCmd(\"AT+CWMODE=1\")\n        result = waitAtResponse(\"OK\", \"ERROR\", \"None\", 1000)\n\n        sendAtCmd(`AT+CWJAP=\"${ssid}\",\"${passwd}\"`)\n        result = waitAtResponse(\"WIFI GOT IP\", \"ERROR\", \"None\", 20000)\n\n        if (result == 1) {\n            isWifiConnected = true\n        }\n    }\n\n    /**\n     * Check if it is connected to Wifi\n     */\n    //% block=\"Wifi OK?\"\n    export function wifiOK() {\n        return isWifiConnected\n    }\n\n    /**\n     * Execute HTTP method.\n     * @param method HTTP method, eg: HttpMethod.GET\n     * @param host Host, eg: \"google.com\"\n     * @param port Port, eg: 80\n     * @param urlPath Path, eg: \"/api/search?q=something\"\n     * @param parameter_name_1 Name of paramter 1\n     * @param parameter_1 Value of paramter 1\n     * @param parameter_name_2 Name of paramter 2\n     * @param parameter_2 Value of paramter 2\n     */\n    //% block=\"execute HTTP method %method|host: %host|port: %port|path: %urlPath||parameter_name_1: %parameter_name_1|parameter_1: %parameter_1|parameter_name_2: %parameter_name_2|parameter_2: %parameter_2\"\n    export function executeHttpMethod(method: HttpMethod, host: string, port: number, urlPath: string, parameter_name_1?: string, parameter_1?: number, parameter_name_2?: string, parameter_2?: number): void {\n        let result = 0\n        let retry = 2\n\n        let myMethod: string\n        switch (method) {\n            case HttpMethod.GET: myMethod = \"GET\"; break;\n            case HttpMethod.POST: myMethod = \"POST\"; break;\n            case HttpMethod.PUT: myMethod = \"PUT\"; break;\n            case HttpMethod.HEAD: myMethod = \"HEAD\"; break;\n            case HttpMethod.DELETE: myMethod = \"DELETE\"; break;\n            case HttpMethod.PATCH: myMethod = \"PATCH\"; break;\n            case HttpMethod.OPTIONS: myMethod = \"OPTIONS\"; break;\n            case HttpMethod.CONNECT: myMethod = \"CONNECT\"; break;\n            case HttpMethod.TRACE: myMethod = \"TRACE\";\n        }\n\n        // close the previous TCP connection\n        if (isWifiConnected) {\n            sendAtCmd(\"AT+CIPCLOSE\")\n            waitAtResponse(\"OK\", \"ERROR\", \"None\", 2000)\n        }\n\n        while (isWifiConnected && retry > 0) {\n            retry = retry - 1;\n            // Establish TCP connection:\n            sendAtCmd(\"AT+CIPSTART=\\\"TCP\\\",\\\"\" + host + \"\\\",\" + port.toString())\n            result = waitAtResponse(\"OK\", \"ALREADY CONNECTED\", \"ERROR\", 2000)\n            if (result == 3) continue\n            let data = myMethod + \" \" + urlPath\n            if (parameter_name_1 && parameter_name_1.length > 0) {\n                data += \"&\" + parameter_name_1 + \"=\" + parameter_1.toString()\n            }\n            if (parameter_name_2 && parameter_name_2.length > 0) {\n                data += \"&\" + parameter_name_2 + \"=\" + parameter_2.toString()\n            }\n            data += \" HTTP/1.1\" + \"\\u000D\" + \"\\u000A\"\n                + \"Host: \" + host + \"\\u000D\" + \"\\u000A\"\n            // Send data:\n            sendAtCmd(\"AT+CIPSEND=\" + (data.length + 2))\n            result = waitAtResponse(\">\", \"OK\", \"ERROR\", 2000)\n            if (result == 3) continue\n            sendAtCmd(data)\n            result = printResponse(\"SEND OK\", \"SEND FAIL\", \"ERROR\", 5000)\n\n            // close the TCP connection\n            sendAtCmd(\"AT+CIPCLOSE\")\n            waitAtResponse(\"OK\", \"ERROR\", \"None\", 2000)\n\n            if (result == 1) break\n        }\n    }\n\n    function waitAtResponse(target1: string, target2: string, target3: string, timeout: number) {\n        let buffer = \"\"\n        let start = input.runningTime()\n\n        while ((input.runningTime() - start) < timeout) {\n            buffer += serial.readString()\n\n            if (buffer.includes(target1)) return 1\n            if (buffer.includes(target2)) return 2\n            if (buffer.includes(target3)) return 3\n\n            basic.pause(100)\n        }\n\n        return 0\n    }\n\n    function printResponse(target1: string, target2: string, target3: string, timeout: number) {\n        let buffer = \"\"\n        let start = input.runningTime()\n\n        while ((input.runningTime() - start) < timeout) {\n            buffer += serial.readString()\n\n            if (buffer.includes(target2)) return 2\n            if (buffer.includes(target3)) return 3\n\n            basic.pause(100)\n        }\n\n        basic.showString(buffer)\n        if (buffer.includes(target1)) return 1\n\n        return 0\n    }\n\n    function sendAtCmd(cmd: string) {\n        serial.writeString(cmd + \"\\u000D\\u000A\")\n    }\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":5381,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":240,"start2":240,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// 在這裡測試；當此封包作為擴充功能時，將不會編譯此內容。\n"}]}],"snapshots":[{"timestamp":1745759943155,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-httpresponse\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1745760006964}